import { UAppTheme } from "../../sleek-ui/app-theme.slint";


component Scrollbar inherits Rectangle {
    in-out property <Orientation> orientation: vertical;
    in-out property <length> value;
    in-out property <length> max-scroll-pos;
    in property <length> handle-size;
    out property <bool> pressed <=> touch.pressed;
    private property <bool> is-vertical: orientation == Orientation.vertical;
    private property <length> available-space: (is-vertical ? self.height : self.width) - handle-size;
    private property <float> min-handle-pct: 0.05;
    private property <bool> is-being-dragged;
    width: root.is-vertical ? 8px : 0;
    height: !root.is-vertical ? 8px : 0;
    handle := Rectangle {
        x: !root.is-vertical ? -value / max-scroll-pos * (root.width - handle-size) : 1px;
        y: root.is-vertical ? -value / max-scroll-pos * (root.height - handle-size) : 1px;
        width: root.is-vertical ? 6px : handle-size;
        height: !root.is-vertical ? 6px : handle-size;
        background: UAppTheme.color-fill;
        border-radius: UAppTheme.radius-circle;
        animate background { duration: UAppTheme.animation-duration; }
        states [
            hover when touch.has-hover: {
                background: UAppTheme.color-fill-plus;
            }
        ]
    }

    touch := TouchArea {
        private property <length> initial-pressed;
        clicked => {
            if is-being-dragged {
                is-being-dragged = false;
                return;
            }
            let mouse-pos = root.is-vertical ? self.mouse-y : self.mouse-x;
            if root.is-vertical && self.mouse-y >= 0 && self.mouse-y <= root.height {
                compute-pos(mouse-pos - handle.height / 2);
            } else if !root.is-vertical && self.mouse-x >= 0 && self.mouse-x <= root.width {
                compute-pos(mouse-pos - handle.width / 2);
            }
        }
        pointer-event(event) => {
            if event.button == PointerEventButton.left && event.kind == PointerEventKind.down {
                initial-pressed = root.is-vertical ? self.mouse-y : self.mouse-x;
            }
        }
        moved => {
            is-being-dragged = true;
            if root.is-vertical && self.mouse-y >= 0 && self.mouse-y <= root.height {
                let move-diff = initial-pressed - self.mouse-y;
                initial-pressed = self.mouse-y;
                compute-pos(handle.y - move-diff);
            } else if !root.is-vertical && self.mouse-x >= 0 && self.mouse-x <= root.width {
                let move-diff = initial-pressed - self.mouse-x;
                initial-pressed = self.mouse-x;
                compute-pos(handle.x - move-diff);
            }
        }
    }

    function compute-pos(move: length) {
        let new-pos = clamp(move, 0px, available-space);
        value = -(max-scroll-pos * (new-pos / available-space));
    }
}

export component UScrollView inherits FocusScope {
    in-out property <bool> interactive: false;
    out property <length> scrollbar-area: 8px;
    in-out property <length> viewport-x <=> flickable.viewport-x;
    in-out property <length> viewport-y <=> flickable.viewport-y;
    in-out property <length> viewport-width <=> flickable.viewport-width;
    in-out property <length> viewport-height <=> flickable.viewport-height;
    private property <length> min-handle-size: 30px;
    private property <duration> scroll-anim-duration: !v-scrollbar.pressed && !h-scrollbar.pressed ? UAppTheme.animation-duration : 0;
    public function scroll-x-to(new-x: length) {
        self.viewport-x = new-x;
    }
    public function scroll-y-to(new-y: length) {
        self.viewport-y = new-y;
    }
    VerticalLayout {
        flickable := Flickable {
            horizontal-stretch: 2;
            vertical-stretch: 2;
            interactive: root.interactive;
            viewport-y <=> v-scrollbar.value;
            viewport-x <=> h-scrollbar.value;
            animate viewport-x, viewport-y { duration: scroll-anim-duration; }
            @children
        }
    }

    v-scrollbar := Scrollbar {
        property <length> raw-handle-size: flickable.height / flickable.viewport-height * self.height;
        y: 0;
        x: root.width - self.width;
        height: root.height - (h-scrollbar.visible ? h-scrollbar.height : 0);
        visible: flickable.viewport-height > flickable.height;
        max-scroll-pos: flickable.viewport-height - flickable.height;
        handle-size: raw-handle-size < min-handle-size ? min-handle-size : raw-handle-size;
    }

    h-scrollbar := Scrollbar {
        property <length> raw-handle-size: flickable.width / flickable.viewport-width * self.width;
        orientation: horizontal;
        x: 0;
        y: root.height - self.height;
        width: root.width - (v-scrollbar.visible ? v-scrollbar.width : 0);
        visible: flickable.viewport-width > flickable.width;
        max-scroll-pos: flickable.viewport-width - flickable.width;
        handle-size: raw-handle-size < min-handle-size ? min-handle-size : raw-handle-size;
    }

    capture-key-pressed(event) => {
        if event.modifiers.shift {
            if event.text == Key.PageDown {
                self.viewport-x -= self.viewport-width * 0.1;
            } else if event.text == Key.PageUp {
                self.viewport-x += self.viewport-width * 0.1;
            } else if event.text == Key.Home {
                self.viewport-x += self.viewport-width;
            } else if event.text == Key.End {
                self.viewport-x -= self.viewport-width;
            }
        } else if event.text == Key.PageDown {
            self.viewport-y -= self.viewport-height * 0.1;
        } else if event.text == Key.PageUp {
            self.viewport-y += self.viewport-height * 0.1;
        } else if event.text == Key.Home {
            self.viewport-y += self.viewport-height;
        } else if event.text == Key.End {
            self.viewport-y -= self.viewport-height;
        }
        reject
    }
}
