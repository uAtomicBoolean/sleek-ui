import { UAppTheme } from "../app-theme.slint";
import { UIcon } from "icon.slint";
import { UText } from "text.slint";


export component UInput inherits Rectangle {
	// Accessability properties
	accessible-role: text-input;
    accessible-read-only: input.read-only;
    accessible-value: self.text;
    accessible-placeholder-text: self.placeholder;
    accessible-action-default => {
        self.accepted()
    }
    accessible-action-set-value(value) => {
        input.text = value;
    }
	// Regular properties
    in-out property <string> text <=> input.text;
    in-out property <bool> enabled <=> input.enabled;
    in-out property <InputType> input-type: InputType.text;
    in-out property <string> placeholder: "";
    in-out property <bool> clearable: false;
    in-out property <bool> error: false;
    private property <bool> show: false;
    border-width: UAppTheme.border-width-base;
    border-radius: UAppTheme.radius-base;
    border-color: UAppTheme.border;
    background: UAppTheme.bg-elevated;
    clip: true;
    HorizontalLayout {
        width: root.width;
        HorizontalLayout {
            padding-left: UAppTheme.padding-horizontal / 2;
            padding-right: UAppTheme.padding-horizontal / 2;
            Rectangle {
                height: UAppTheme.font-size-base + UAppTheme.padding-vertical * 3;
                clip: true;
                input := TextInput {
                    private property <length> cursor-padding: UAppTheme.padding-horizontal / 2 * 3;
                    private property <length> x-pos;
                    width: max(parent.width, self.preferred-width);
                    x: min(x-pos, 0px);
                    input-type: show ? InputType.text : input-type;
                    read-only: !root.enabled;
                    font-size: UAppTheme.font-size-base;
                    color: UAppTheme.text;
                    vertical-alignment: center;
                    horizontal-alignment: left;
                    single-line: true;
                    wrap: no-wrap;
                    // Disable the TextInput accessability as the widget takes care of that.
                    accessible-role: none;
                    cursor-position-changed(cpos) => {
                        if cpos.x - self.cursor-padding < - self.x-pos {
                            self.x-pos = self.cursor-padding - cpos.x;
                        } else if cpos.x + self.x-pos > parent.width - self.text-cursor-width {
                            self.x-pos = parent.width - cpos.x - self.text-cursor-width;
                        }
                    }
                    if self.text == "" && placeholder != "": HorizontalLayout {
                        alignment: start;
                        VerticalLayout {
                            alignment: center;
                            UText {
                                text: placeholder;
                                color: UAppTheme.text-disabled;
                            }
                        }
                    }
                }
            }
        }

        if clearable && input-type != InputType.password: VerticalLayout {
            alignment: center;
            padding-left: -UAppTheme.padding-horizontal / 2;
            Rectangle {
                height: 100%;
                width: UAppTheme.icon-size-base + UAppTheme.padding-horizontal / 2;
                UIcon {
                    size: UAppTheme.icon-size-base;
                    colorize: UAppTheme.text-secondary;
                    source: @image-url("../assets/icons/circle-x.svg");
                }

                TouchArea {
                    accessible-role: button;
                    accessible-label: @tr("Clear input.");
                    mouse-cursor: MouseCursor.pointer;
                    clicked => {
                        text = "";
                        input.set-selection-offsets(0, 0);
                    }
                }
            }
        }
        if input-type == InputType.password: VerticalLayout {
            alignment: center;
            padding-left: -UAppTheme.padding-horizontal / 2;
            Rectangle {
                height: 100%;
                width: UAppTheme.icon-size-base + UAppTheme.padding-horizontal / 2;
                UIcon {
                    size: UAppTheme.icon-size-base;
                    colorize: UAppTheme.text-secondary;
                    source: show ? @image-url("../assets/icons/eye.svg") : @image-url("../assets/icons/eye-closed.svg");
                }

                TouchArea {
                    accessible-role: button;
                    accessible-label: @tr("Show password input content.");
                    mouse-cursor: MouseCursor.pointer;
                    clicked => {
                        show = !show;
                        if show {
                            input.input-type = InputType.text;
                        } else {
                            input.input-type = InputType.password;
                        }
                    }
                }
            }
        }
    }

    states [
        disabled when !input.enabled: {
            background: UAppTheme.bg-elevated.with-alpha(0.4);
            border-color: UAppTheme.border-secondary;
            input.color: UAppTheme.text-disabled;
        }
        error when error: {
            background: UAppTheme.bg-elevated;
            border-color: UAppTheme.danger.base;
        }
        active when input.has-focus: {
            background: UAppTheme.bg-elevated;
            border-color: UAppTheme.primary.active;
        }
    ]

    // Link the functions and callback of TextInput to child.
	public function set-selection-offsets(start: int, end: int) {
        input.set-selection-offsets(start, end);
    }
    public function select-all() {
        input.select-all();
    }
    public function clear-selection() {
        input.clear-selection();
    }
    public function copy() {
        input.copy();
    }
    public function cut() {
        input.cut();
    }
    public function paste() {
        input.paste();
    }
    callback accepted <=> input.accepted;
    callback cursor-position-changed <=> input.cursor-position-changed;
    callback edited <=> input.edited;
    callback key-pressed <=> input.key-pressed;
    callback key-released <=> input.key-released;
}
