import { UText } from "text.slint";
import { UAppTheme } from "../app-theme.slint";


enum UTooltipPosition {
	top,
	bottom,
	left,
	right
}

export global UTooltipLogic {
    out property <bool> user_hovering;
    out property <string> text;
    out property <UTooltipPosition> position;
    out property <length> x;
    out property <length> y;
    out property <length> width;
    out property <length> height;
    public function display(text: string, position: string, user_hovering: bool, coords: Point, width: length, height: length) {
        self.user_hovering = user-hovering;
        if self.user_hovering {
            self.text = text;
            self.position = position == "left" ? UTooltipPosition.left : position == "right" ? UTooltipPosition.right : position == "bottom" ? UTooltipPosition.bottom : UTooltipPosition.top;
            self.x = coords.x;
            self.y = coords.y;
            self.width = width;
            self.height = height;
        }
    }
}

export component UTooltip {
	// Regular properties
    in-out property <duration> delay: 250ms;
    in-out property <length> tooltip-max-width: 150px;
    in-out property <length> tooltip-max-height;
    private property <bool> has_waited: false;
    private property <bool> user_is_hovering: UTooltipLogic.user_hovering;
    z: 100;
    x: compute-x-position();
    y: compute-y-position();
    changed user_is_hovering => {
        if !user_is_hovering && has_waited {
            has_waited = false;
        }
    }
    content := Rectangle {
        z: 100;
        background: UAppTheme.bg-inverse;
        border-radius: UAppTheme.radius-base;
        opacity: has_waited ? 1 : 0;
        HorizontalLayout {
            padding: UAppTheme.padding-base;
            UText {
                opacity: has_waited ? 1 : 0;
                text: UTooltipLogic.text;
                color: UAppTheme.inverse-text;
                font-size: UAppTheme.font-size-small;
                wrap: word-wrap;
                max-width: tooltip-max-width;
                max-height: tooltip-max-height;
                animate opacity { duration: UAppTheme.animation-duration; }
            }
        }

        animate opacity { duration: UAppTheme.animation-duration; }
    }

    Timer {
        running: user_is_hovering;
        interval: delay;
        triggered => {
            has_waited = true;
        }
    }

    function compute-x-position() -> length {
        if (UTooltipLogic.position == UTooltipPosition.left) {
            return UTooltipLogic.x - content.width - UAppTheme.spacing-base;
        } else if (UTooltipLogic.position == UTooltipPosition.right) {
            return UTooltipLogic.x + UTooltipLogic.width + UAppTheme.spacing-base;
        } else if (UTooltipLogic.position == UTooltipPosition.top || UTooltipLogic.position == UTooltipPosition.bottom) {
            return UTooltipLogic.x - (content.width - UTooltipLogic.width) / 2;
        }
        return UTooltipLogic.x;
    }
    function compute-y-position() -> length {
        if (UTooltipLogic.position == UTooltipPosition.top) {
            return UTooltipLogic.y - content.height - UAppTheme.spacing-base;
        } else if (UTooltipLogic.position == UTooltipPosition.bottom) {
            return UTooltipLogic.y + UTooltipLogic.height + UAppTheme.spacing-base;
        } else if (UTooltipLogic.position == UTooltipPosition.left || UTooltipLogic.position == UTooltipPosition.right) {
            return UTooltipLogic.y - (content.height - UTooltipLogic.height) / 2;
        }
        return UTooltipLogic.y;
    }
}
