import { UAppTheme } from "../app-theme.slint";
import { ButtonInterface } from "button-interface.slint";
import { UText } from "./text.slint";


export enum URadioButtonVariant {
	default,
	primary,
}

// Used to manage the different variant styles.
// Only the properties with differences are declared in the struct.
struct URadionButtonTheme {
    bg-selected: brush,
    bg-selected-hover: brush,
    bg-selected-active: brush,
    text-selected: brush,
    text-selected-hover: brush,
    text-selected-active: brush,
}

global URadioButtonThemes {
    out property <URadionButtonTheme> default: {
        text-selected: UAppTheme.primary.base,
        text-selected-hover: UAppTheme.primary.hover,
        text-selected-active: UAppTheme.primary.active,
    };
    out property <URadionButtonTheme> primary: {
        bg-selected: UAppTheme.primary.base,
        bg-selected-hover: UAppTheme.primary.hover,
        bg-selected-active: UAppTheme.primary.active,
        text-selected: Colors.white,
        text-selected-hover: Colors.white,
        text-selected-active: Colors.white,
    };
}

export component URadioButton {
    accessible-role: combobox;
    accessible-label: "Radio button";
    accessible-value: selected-value;
	// Regular properties
	in-out property <URadioButtonVariant> variant: default;
    property <URadionButtonTheme> theme: {
        if variant == URadioButtonVariant.primary {
            return URadioButtonThemes.primary;
        }
        return URadioButtonThemes.default;
    };
    in-out property <[string]> options;
    in-out property <string> selected-value: options[0];
    callback selected(value: string);
    HorizontalLayout {
        for option[idx] in root.options: ButtonInterface {
            border-width: UAppTheme.border-width-base;
            border-color: UAppTheme.border;
            init => {
                if idx == 0 {
                    self.border-top-left-radius = UAppTheme.radius-base;
                    self.border-bottom-left-radius = UAppTheme.radius-base;
                } else if idx == options.length - 1 {
                    self.border-top-right-radius = UAppTheme.radius-base;
                    self.border-bottom-right-radius = UAppTheme.radius-base;
                }
            }
            clicked => {
                selected-value = option;
                root.selected(option);
            }
            HorizontalLayout {
                alignment: center;
                padding-top: UAppTheme.padding-vertical;
                padding-bottom: UAppTheme.padding-vertical;
                padding-left: UAppTheme.padding-horizontal;
                padding-right: UAppTheme.padding-horizontal;
                VerticalLayout {
                    alignment: center;
                    option-text := UText {
                        text: option;
                        color: UAppTheme.text;
                        font-size: UAppTheme.font-size-base;
                        animate color {
                            easing: ease;
                            duration: 200ms;
                        }
                    }
                }
            }

            states [
                focus-not-selected-hover when self.has-focus && selected-value != option && self.has-hover: {
                    border-width: UAppTheme.focus-border-width;
                    border-color: UAppTheme.focus-color;
                }
                focus-selected-hover when self.has-focus && selected-value == option && self.has-hover: {
                    border-width: UAppTheme.focus-border-width;
                    border-color: UAppTheme.focus-color;
                    background: theme.bg-selected-hover;
                    option-text.color: theme.text-selected-hover;
                }
                focus-selected when self.has-focus && selected-value == option: {
                    border-width: UAppTheme.focus-border-width;
                    border-color: UAppTheme.focus-color;
                    background: theme.bg-selected;
                    option-text.color: theme.text-selected;
                }
                focus when self.has-focus: {
                    border-width: UAppTheme.focus-border-width;
                    border-color: UAppTheme.focus-color;
                }
                active-selected when self.pressed && selected-value == option: {
                    background: theme.bg-selected-active;
                    border-color: UAppTheme.primary.active;
                    option-text.color: theme.text-selected-active;
                }
                hover-not-selected when self.has-hover && selected-value != option: {
                    border-color: UAppTheme.border;
                    option-text.color: UAppTheme.primary.base;
                }
                hover-selected when self.has-hover && selected-value == option: {
                    background: theme.bg-selected-hover;
                    border-color: UAppTheme.primary.hover;
                    option-text.color: theme.text-selected-hover;
                }
                selected when selected-value == option: {
                    background: theme.bg-selected;
                    border-color: UAppTheme.primary.base;
                    option-text.color: theme.text-selected;
                }
            ]
        }
    }
}
